&vertex_source:
"#version 300 es

 // Declaring and transmitting vertex attributes is annoying, so instead we're
 // doing everything with uniforms and the gl_VertexID.
uniform int u_orientation;
uniform float u_screen_rect [4];
uniform float u_tex_rect [4];
out vec2 v_tex_coords;

 // TODO: reorder
const int RIGHT = 0;
const int LEFT = 1;
const int DOWN = 2;
const int UP = 3;

const ivec2 corners [4] = ivec2[4](
    ivec2(0, 1),
    ivec2(2, 1),
    ivec2(2, 3),
    ivec2(0, 3)
);

void main () {
     // Here we flip from y-down to y-up coordinates
    gl_Position.x = u_screen_rect[corners[gl_VertexID].x];
    gl_Position.y = -u_screen_rect[corners[gl_VertexID].y];
     // Rotating is easy when [0 0] is in the center of the screen
    switch (u_orientation) {
        case UP: break;
        case DOWN:
            gl_Position.xy = -gl_Position.xy;
            break;
        case LEFT:
            gl_Position.xy = vec2(-gl_Position.y, gl_Position.x);
            break;
        case RIGHT:
            gl_Position.xy = vec2(gl_Position.y, -gl_Position.x);
            break;
    }
    gl_Position.zw = vec2(0, 1);
    v_tex_coords.x = u_tex_rect[corners[gl_VertexID].x];
    v_tex_coords.y = u_tex_rect[corners[gl_VertexID].y];
}"

&fragment_source:
"#version 300 es
precision highp float;
precision highp int;

uniform sampler2D u_tex;
uniform int u_interpolator;
uniform vec4 u_transparency_background;
uniform float u_zoom;
uniform vec3 u_color_mul;
uniform vec3 u_color_add;
in vec2 v_tex_coords;
out vec4 color;

 // These must match enum class Interpolator in page.cpp
const int NEAREST = 0;
const int LINEAR = 1;
const int CUBIC = 2;
const int CUBIC_RINGLESS = 3;
const int LANCZOS16 = 4;
const int SQUARES9 = 5;
const int SQUARES16 = 6;
const int SQUARES25 = 7;
const int SQUARES36 = 8;
const int SQUARES49 = 9;
//const int SQUARES64 = 10;

 // With help from
 // https://blog.demofox.org/2015/08/15/resizing-images-with-bicubic-interpolation/
 // https://en.wikipedia.org/wiki/Bicubic_interpolation
vec4 cubic_hermite (vec4 a, vec4 b, vec4 c, vec4 d, float t) {
     // I'd use a matrix here, but I don't think GLSL supports matrixes with
     // vectors as their individual components. :)
    vec4 v0 =         2.0*b;
    vec4 v1 =    -a         +     c;
    vec4 v2 = 2.0*a - 5.0*b + 4.0*c - d;
    vec4 v3 =    -a + 3.0*b - 3.0*c + d;
    return (v0 + v1*t + v2*(t*t) + v3*(t*t*t)) / 2.0;
}

float sinc (float x) {
    return sin(x) / x;
}

#define PI 3.1415926538
float lanczos2 (float x) {
    if (x == 0.0) return 1.0;
    float pix = PI*x;
    return sinc(pix) * sinc(pix / 2.0);
}

vec4 sliding_area_3 (vec4 a, vec4 b, vec4 c, float frac) {
    float zoom = clamp(u_zoom, 1.0/2.0, 1.0);
    float expand = 1.0/zoom;

     //            | frac=0.0 | frac=0.5 | frac=1.0
     // expand=1.0 |  wa=0.5  |  wa=0.0  |  wa=0.0
     // expand=1.5 |  wa=0.75 |  wa=0.25 |  wa=0.0
     // expand=2.0 |  wa=1.0  |  wa=0.5  |  wa=0.0

     //            | frac=0.0 | frac=0.5 | frac=1.0
     // expand=1.0 |  wb=0.5  |  wb=1.0  |  wb=0.5
     // expand=1.5 |  wb=0.75 |  wb=1.0  |  wb=0.75
     // expand=2.0 |  wb=1.0  |  wb=1.0  |  wb=1.0

    float base = 0.5 * expand;

    float wa = max(0.0, base - frac);
    float wb = min(1.0, base + min(frac, 1.0 - frac));
    float wc = max(0.0, base - (1.0 - frac));
    return (wa*a + wb*b + wc*c) * zoom;
}

vec4 sliding_area_4 (vec4 a, vec4 b, vec4 c, vec4 d, float frac) {
    float zoom = clamp(u_zoom, 1.0/3.0, 1.0/2.0);
    float expand = 1.0/zoom;

     //            | frac=0.0 | frac=0.5 | frac=1.0
     // expand=2.0 |  wa=0.5  |  wa=0.0  |  wa=0.0
     // expand=2.5 |  wa=0.75 |  wa=0.25 |  wa=0.0
     // expand=3.0 |  wa=1.0  |  wa=0.5  |  wa=0.0

     //            | frac=0.0 | frac=0.5 | frac=1.0
     // expand=2.0 |  wb=1.0  |  wb=1.0  |  wb=0.5
     // expand=2.5 |  wb=1.0  |  wb=1.0  |  wb=0.75
     // expand=3.0 |  wb=1.0  |  wb=1.0  |  wb=1.0

    float base = 0.5 * (expand - 1.0);

    float wa = max(0.0, base - frac);
    float wb = min(1.0, base + (1.0 - frac));
    float wc = min(1.0, base + frac);
    float wd = max(0.0, base - (1.0 - frac));
    return (wa*a + wb*b + wc*c + wd*d) * zoom;
}

vec4 sliding_area_5 (vec4 a, vec4 b, vec4 c, vec4 d, vec4 e, float frac) {
    float zoom = clamp(u_zoom, 1.0/4.0, 1.0/3.0);
    float expand = 1.0/zoom;
    float base = 0.5 * (expand - 2.0);
    float wa = max(0.0, base - frac);
    float wb = min(1.0, base + (1.0 - frac));
    float wc = 1.0;
    float wd = min(1.0, base + frac);
    float we = max(0.0, base - (1.0 - frac));
    return (wa*a + wb*b + wc*c + wd*d + we*e) * zoom;
}

vec4 sliding_area_6 (vec4 a, vec4 b, vec4 c, vec4 d, vec4 e, vec4 f, float frac) {
    float zoom = clamp(u_zoom, 1.0/5.0, 1.0/4.0);
    float expand = 1.0/zoom;
    float base = 0.5 * (expand - 3.0);
    float wa = max(0.0, base - frac);
    float wb = min(1.0, base + (1.0 - frac));
    float wc = 1.0;
    float wd = 1.0;
    float we = min(1.0, base + frac);
    float wf = max(0.0, base - (1.0 - frac));
    return (wa*a + wb*b + wc*c + wd*d + we*e + wf*f) * zoom;
}

vec4 sliding_area_7 (vec4 a, vec4 b, vec4 c, vec4 d, vec4 e, vec4 f, vec4 g, float frac) {
    float zoom = clamp(u_zoom, 1.0/6.0, 1.0/5.0);
    float expand = 1.0/zoom;
    float base = 0.5 * (expand - 4.0);
    float wa = max(0.0, base - frac);
    float wb = min(1.0, base + (1.0 - frac));
    float wc = 1.0;
    float wd = 1.0;
    float we = 1.0;
    float wf = min(1.0, base + frac);
    float wg = max(0.0, base - (1.0 - frac));
    return (wa*a + wb*b + wc*c + wd*d + we*e + wf*f + wg*g) * zoom;
}

//vec4 sliding_area_8 (vec4 a, vec4 b, vec4 c, vec4 d, vec4 e, vec4 f, vec4 g, vec4 h, float frac) {
//    float zoom = clamp(u_zoom, 1.0/7.0, 1.0/6.0);
//    float expand = 1.0/zoom;
//    float base = 0.5 * (expand - 5.0);
//    float wa = max(0.0, base - frac);
//    float wb = min(1.0, base + (1.0 - frac));
//    float wc = 1.0;
//    float wd = 1.0;
//    float we = 1.0;
//    float wf = 1.0;
//    float wg = min(1.0, base + frac);
//    float wh = max(0.0, base - (1.0 - frac));
//    return (wa*a + wb*b + wc*c + wd*d + we*e + wf*f + wg*g + wh*h) * zoom;
//}

void main () {
    switch (u_interpolator) {
        default: // error on some drivers: color may be used uninitialized
        case NEAREST: {
            color = texelFetch(u_tex, ivec2(floor(v_tex_coords)), 0);
            break;
        }
        case LINEAR: {
            vec2 lookup_coords = v_tex_coords / vec2(textureSize(u_tex, 0));
            color = texture(u_tex, lookup_coords);
            break;
        }
        case SQUARES9: {
             // Supersampling downscaling for zoom levels between 1 and 1/2.
             // Because the square is an odd number wide, don't adjust coords by
             // 0.5.
            vec2 int_coords = floor(v_tex_coords);
            vec2 frac_coords = v_tex_coords - int_coords;
            vec2 lookup_coords = int_coords / vec2(textureSize(u_tex, 0));
            vec4 s00 = textureOffset(u_tex, lookup_coords, ivec2(-1, -1));
            vec4 s10 = textureOffset(u_tex, lookup_coords, ivec2(+0, -1));
            vec4 s20 = textureOffset(u_tex, lookup_coords, ivec2(+1, -1));
            vec4 s01 = textureOffset(u_tex, lookup_coords, ivec2(-1, +0));
            vec4 s11 = textureOffset(u_tex, lookup_coords, ivec2(+0, +0));
            vec4 s21 = textureOffset(u_tex, lookup_coords, ivec2(+1, +0));
            vec4 s02 = textureOffset(u_tex, lookup_coords, ivec2(-1, +1));
            vec4 s12 = textureOffset(u_tex, lookup_coords, ivec2(+0, +1));
            vec4 s22 = textureOffset(u_tex, lookup_coords, ivec2(+1, +1));
            vec4 r0 = sliding_area_3(s00, s10, s20, frac_coords.x);
            vec4 r1 = sliding_area_3(s01, s11, s21, frac_coords.x);
            vec4 r2 = sliding_area_3(s02, s12, s22, frac_coords.x);
            color = sliding_area_3(r0, r1, r2, frac_coords.y);
        }
        case CUBIC:
        case CUBIC_RINGLESS:
        case LANCZOS16:
        case SQUARES16: {
             // It's easy to run into off-by-one-half errors, because texels
             // aren't centered around integer coordinates, they're centered
             // around (_.5,_.5) coordinates.
            vec2 adjusted_coords = v_tex_coords - 0.5;
            vec2 int_coords = floor(adjusted_coords);
            vec2 frac_coords = adjusted_coords - int_coords;
             // Use textureOffset instead of texelFetchOffset because the
             // latter bypasses GL_CLAMP_TO_BORDER...but then we have to
             // add the 0.5 back.
            vec2 lookup_coords = (int_coords + 0.5) / vec2(textureSize(u_tex, 0));
            vec4 s00 = textureOffset(u_tex, lookup_coords, ivec2(-1, -1));
            vec4 s10 = textureOffset(u_tex, lookup_coords, ivec2(+0, -1));
            vec4 s20 = textureOffset(u_tex, lookup_coords, ivec2(+1, -1));
            vec4 s30 = textureOffset(u_tex, lookup_coords, ivec2(+2, -1));
            vec4 s01 = textureOffset(u_tex, lookup_coords, ivec2(-1, +0));
            vec4 s11 = textureOffset(u_tex, lookup_coords, ivec2(+0, +0));
            vec4 s21 = textureOffset(u_tex, lookup_coords, ivec2(+1, +0));
            vec4 s31 = textureOffset(u_tex, lookup_coords, ivec2(+2, +0));
            vec4 s02 = textureOffset(u_tex, lookup_coords, ivec2(-1, +1));
            vec4 s12 = textureOffset(u_tex, lookup_coords, ivec2(+0, +1));
            vec4 s22 = textureOffset(u_tex, lookup_coords, ivec2(+1, +1));
            vec4 s32 = textureOffset(u_tex, lookup_coords, ivec2(+2, +1));
            vec4 s03 = textureOffset(u_tex, lookup_coords, ivec2(-1, +2));
            vec4 s13 = textureOffset(u_tex, lookup_coords, ivec2(+0, +2));
            vec4 s23 = textureOffset(u_tex, lookup_coords, ivec2(+1, +2));
            vec4 s33 = textureOffset(u_tex, lookup_coords, ivec2(+2, +2));
            switch (u_interpolator) {
                default:
                case CUBIC:
                case CUBIC_RINGLESS: {
                    vec4 r0 = cubic_hermite(s00, s10, s20, s30, frac_coords.x);
                    vec4 r1 = cubic_hermite(s01, s11, s21, s31, frac_coords.x);
                    vec4 r2 = cubic_hermite(s02, s12, s22, s32, frac_coords.x);
                    vec4 r3 = cubic_hermite(s03, s13, s23, s33, frac_coords.x);
                    color = cubic_hermite(r0, r1, r2, r3, frac_coords.y);
                    break;
                }
                case LANCZOS16: {
                    float xw0 = lanczos2(-1.0 - frac_coords.x);
                    float xw1 = lanczos2(+0.0 - frac_coords.x);
                    float xw2 = lanczos2(+1.0 - frac_coords.x);
                    float xw3 = lanczos2(+2.0 - frac_coords.x);
                    float yw0 = lanczos2(-1.0 - frac_coords.y);
                    float yw1 = lanczos2(+0.0 - frac_coords.y);
                    float yw2 = lanczos2(+1.0 - frac_coords.y);
                    float yw3 = lanczos2(+2.0 - frac_coords.y);
                    color = (s00*(xw0*yw0) + s10*(xw1*yw0) + s20*(xw2*yw0) + s30*(xw3*yw0))
                          + (s01*(xw0*yw1) + s11*(xw1*yw1) + s21*(xw2*yw1) + s31*(xw3*yw1))
                          + (s02*(xw0*yw2) + s12*(xw1*yw2) + s22*(xw2*yw2) + s32*(xw3*yw2))
                          + (s03*(xw0*yw3) + s13*(xw1*yw3) + s23*(xw2*yw3) + s33*(xw3*yw3));
                    break;
                }
                case SQUARES16: {
                    vec4 r0 = sliding_area_4(s00, s10, s20, s30, frac_coords.x);
                    vec4 r1 = sliding_area_4(s01, s11, s21, s31, frac_coords.x);
                    vec4 r2 = sliding_area_4(s02, s12, s22, s32, frac_coords.x);
                    vec4 r3 = sliding_area_4(s03, s13, s23, s33, frac_coords.x);
                    color = sliding_area_4(r0, r1, r2, r3, frac_coords.y);
                    break;
                }
                break;
            }
             // Clamp output to prevent haloing.  Ideally we would
             // adjust the derivative at s[1-2][1-2] to prevent haloing,
             // AKA monotonic cubic interpolation, but that looks really
             // complicated and expensive.  So we're clamping the output
             // instead.  It doesn't always preserve the first
             // derivative, but when it doesn't, it's when the image had
             // a sharp edge anyway, so it looks fine.  This is also not
             // guaranteed to preserve the overall color distribution,
             // but from my observations there's no visible difference.
            if (u_interpolator == CUBIC_RINGLESS || u_interpolator == LANCZOS16) {
                color = clamp(color,
                    min(min(s11, s12), min(s21, s22)),
                    max(max(s11, s12), max(s21, s22))
                );
            }
            break;
        }
        case SQUARES25: {
            vec2 int_coords = floor(v_tex_coords);
            vec2 frac_coords = v_tex_coords - int_coords;
            vec2 lookup_coords = int_coords / vec2(textureSize(u_tex, 0));
            vec4 s00 = textureOffset(u_tex, lookup_coords, ivec2(-2, -2));
            vec4 s10 = textureOffset(u_tex, lookup_coords, ivec2(-1, -2));
            vec4 s20 = textureOffset(u_tex, lookup_coords, ivec2(+0, -2));
            vec4 s30 = textureOffset(u_tex, lookup_coords, ivec2(+1, -2));
            vec4 s40 = textureOffset(u_tex, lookup_coords, ivec2(+2, -2));
            vec4 s01 = textureOffset(u_tex, lookup_coords, ivec2(-2, -1));
            vec4 s11 = textureOffset(u_tex, lookup_coords, ivec2(-1, -1));
            vec4 s21 = textureOffset(u_tex, lookup_coords, ivec2(+0, -1));
            vec4 s31 = textureOffset(u_tex, lookup_coords, ivec2(+1, -1));
            vec4 s41 = textureOffset(u_tex, lookup_coords, ivec2(+2, -1));
            vec4 s02 = textureOffset(u_tex, lookup_coords, ivec2(-2, +0));
            vec4 s12 = textureOffset(u_tex, lookup_coords, ivec2(-1, +0));
            vec4 s22 = textureOffset(u_tex, lookup_coords, ivec2(+0, +0));
            vec4 s32 = textureOffset(u_tex, lookup_coords, ivec2(+1, +0));
            vec4 s42 = textureOffset(u_tex, lookup_coords, ivec2(+2, +0));
            vec4 s03 = textureOffset(u_tex, lookup_coords, ivec2(-2, +1));
            vec4 s13 = textureOffset(u_tex, lookup_coords, ivec2(-1, +1));
            vec4 s23 = textureOffset(u_tex, lookup_coords, ivec2(+0, +1));
            vec4 s33 = textureOffset(u_tex, lookup_coords, ivec2(+1, +1));
            vec4 s43 = textureOffset(u_tex, lookup_coords, ivec2(+2, +1));
            vec4 s04 = textureOffset(u_tex, lookup_coords, ivec2(-2, +2));
            vec4 s14 = textureOffset(u_tex, lookup_coords, ivec2(-1, +2));
            vec4 s24 = textureOffset(u_tex, lookup_coords, ivec2(+0, +2));
            vec4 s34 = textureOffset(u_tex, lookup_coords, ivec2(+1, +2));
            vec4 s44 = textureOffset(u_tex, lookup_coords, ivec2(+2, +2));
            vec4 r0 = sliding_area_5(s00, s10, s20, s30, s40, frac_coords.x);
            vec4 r1 = sliding_area_5(s01, s11, s21, s31, s41, frac_coords.x);
            vec4 r2 = sliding_area_5(s02, s12, s22, s32, s42, frac_coords.x);
            vec4 r3 = sliding_area_5(s03, s13, s23, s33, s43, frac_coords.x);
            vec4 r4 = sliding_area_5(s04, s14, s24, s34, s44, frac_coords.x);
            color = sliding_area_5(r0, r1, r2, r3, r4, frac_coords.y);
            break;
        }
        case SQUARES36: {
            vec2 adjusted_coords = v_tex_coords - 0.5;
            vec2 int_coords = floor(adjusted_coords);
            vec2 frac_coords = adjusted_coords - int_coords;
            vec2 lookup_coords = (int_coords + 0.5) / vec2(textureSize(u_tex, 0));
            vec4 s00 = textureOffset(u_tex, lookup_coords, ivec2(-2, -2));
            vec4 s10 = textureOffset(u_tex, lookup_coords, ivec2(-1, -2));
            vec4 s20 = textureOffset(u_tex, lookup_coords, ivec2(+0, -2));
            vec4 s30 = textureOffset(u_tex, lookup_coords, ivec2(+1, -2));
            vec4 s40 = textureOffset(u_tex, lookup_coords, ivec2(+2, -2));
            vec4 s50 = textureOffset(u_tex, lookup_coords, ivec2(+3, -2));
            vec4 s01 = textureOffset(u_tex, lookup_coords, ivec2(-2, -1));
            vec4 s11 = textureOffset(u_tex, lookup_coords, ivec2(-1, -1));
            vec4 s21 = textureOffset(u_tex, lookup_coords, ivec2(+0, -1));
            vec4 s31 = textureOffset(u_tex, lookup_coords, ivec2(+1, -1));
            vec4 s41 = textureOffset(u_tex, lookup_coords, ivec2(+2, -1));
            vec4 s51 = textureOffset(u_tex, lookup_coords, ivec2(+3, -1));
            vec4 s02 = textureOffset(u_tex, lookup_coords, ivec2(-2, +0));
            vec4 s12 = textureOffset(u_tex, lookup_coords, ivec2(-1, +0));
            vec4 s22 = textureOffset(u_tex, lookup_coords, ivec2(+0, +0));
            vec4 s32 = textureOffset(u_tex, lookup_coords, ivec2(+1, +0));
            vec4 s42 = textureOffset(u_tex, lookup_coords, ivec2(+2, +0));
            vec4 s52 = textureOffset(u_tex, lookup_coords, ivec2(+3, +0));
            vec4 s03 = textureOffset(u_tex, lookup_coords, ivec2(-2, +1));
            vec4 s13 = textureOffset(u_tex, lookup_coords, ivec2(-1, +1));
            vec4 s23 = textureOffset(u_tex, lookup_coords, ivec2(+0, +1));
            vec4 s33 = textureOffset(u_tex, lookup_coords, ivec2(+1, +1));
            vec4 s43 = textureOffset(u_tex, lookup_coords, ivec2(+2, +1));
            vec4 s53 = textureOffset(u_tex, lookup_coords, ivec2(+3, +1));
            vec4 s04 = textureOffset(u_tex, lookup_coords, ivec2(-2, +2));
            vec4 s14 = textureOffset(u_tex, lookup_coords, ivec2(-1, +2));
            vec4 s24 = textureOffset(u_tex, lookup_coords, ivec2(+0, +2));
            vec4 s34 = textureOffset(u_tex, lookup_coords, ivec2(+1, +2));
            vec4 s44 = textureOffset(u_tex, lookup_coords, ivec2(+2, +2));
            vec4 s54 = textureOffset(u_tex, lookup_coords, ivec2(+3, +2));
            vec4 s05 = textureOffset(u_tex, lookup_coords, ivec2(-2, +3));
            vec4 s15 = textureOffset(u_tex, lookup_coords, ivec2(-1, +3));
            vec4 s25 = textureOffset(u_tex, lookup_coords, ivec2(+0, +3));
            vec4 s35 = textureOffset(u_tex, lookup_coords, ivec2(+1, +3));
            vec4 s45 = textureOffset(u_tex, lookup_coords, ivec2(+2, +3));
            vec4 s55 = textureOffset(u_tex, lookup_coords, ivec2(+3, +3));
            vec4 r0 = sliding_area_6(s00, s10, s20, s30, s40, s50, frac_coords.x);
            vec4 r1 = sliding_area_6(s01, s11, s21, s31, s41, s51, frac_coords.x);
            vec4 r2 = sliding_area_6(s02, s12, s22, s32, s42, s52, frac_coords.x);
            vec4 r3 = sliding_area_6(s03, s13, s23, s33, s43, s53, frac_coords.x);
            vec4 r4 = sliding_area_6(s04, s14, s24, s34, s44, s54, frac_coords.x);
            vec4 r5 = sliding_area_6(s05, s15, s25, s35, s45, s55, frac_coords.x);
            color = sliding_area_6(r0, r1, r2, r3, r4, r5, frac_coords.y);
            break;
        }
        case SQUARES49: {
            vec2 int_coords = floor(v_tex_coords);
            vec2 frac_coords = v_tex_coords - int_coords;
            vec2 lookup_coords = int_coords / vec2(textureSize(u_tex, 0));
            vec4 s00 = textureOffset(u_tex, lookup_coords, ivec2(-3, -3));
            vec4 s10 = textureOffset(u_tex, lookup_coords, ivec2(-2, -3));
            vec4 s20 = textureOffset(u_tex, lookup_coords, ivec2(-1, -3));
            vec4 s30 = textureOffset(u_tex, lookup_coords, ivec2(+0, -3));
            vec4 s40 = textureOffset(u_tex, lookup_coords, ivec2(+1, -3));
            vec4 s50 = textureOffset(u_tex, lookup_coords, ivec2(+2, -3));
            vec4 s60 = textureOffset(u_tex, lookup_coords, ivec2(+3, -3));
            vec4 s01 = textureOffset(u_tex, lookup_coords, ivec2(-3, -2));
            vec4 s11 = textureOffset(u_tex, lookup_coords, ivec2(-2, -2));
            vec4 s21 = textureOffset(u_tex, lookup_coords, ivec2(-1, -2));
            vec4 s31 = textureOffset(u_tex, lookup_coords, ivec2(+0, -2));
            vec4 s41 = textureOffset(u_tex, lookup_coords, ivec2(+1, -2));
            vec4 s51 = textureOffset(u_tex, lookup_coords, ivec2(+2, -2));
            vec4 s61 = textureOffset(u_tex, lookup_coords, ivec2(+3, -2));
            vec4 s02 = textureOffset(u_tex, lookup_coords, ivec2(-3, -1));
            vec4 s12 = textureOffset(u_tex, lookup_coords, ivec2(-2, -1));
            vec4 s22 = textureOffset(u_tex, lookup_coords, ivec2(-1, -1));
            vec4 s32 = textureOffset(u_tex, lookup_coords, ivec2(+0, -1));
            vec4 s42 = textureOffset(u_tex, lookup_coords, ivec2(+1, -1));
            vec4 s52 = textureOffset(u_tex, lookup_coords, ivec2(+2, -1));
            vec4 s62 = textureOffset(u_tex, lookup_coords, ivec2(+3, -1));
            vec4 s03 = textureOffset(u_tex, lookup_coords, ivec2(-3, +0));
            vec4 s13 = textureOffset(u_tex, lookup_coords, ivec2(-2, +0));
            vec4 s23 = textureOffset(u_tex, lookup_coords, ivec2(-1, +0));
            vec4 s33 = textureOffset(u_tex, lookup_coords, ivec2(+0, +0));
            vec4 s43 = textureOffset(u_tex, lookup_coords, ivec2(+1, +0));
            vec4 s53 = textureOffset(u_tex, lookup_coords, ivec2(+2, +0));
            vec4 s63 = textureOffset(u_tex, lookup_coords, ivec2(+3, +0));
            vec4 s04 = textureOffset(u_tex, lookup_coords, ivec2(-3, +1));
            vec4 s14 = textureOffset(u_tex, lookup_coords, ivec2(-2, +1));
            vec4 s24 = textureOffset(u_tex, lookup_coords, ivec2(-1, +1));
            vec4 s34 = textureOffset(u_tex, lookup_coords, ivec2(+0, +1));
            vec4 s44 = textureOffset(u_tex, lookup_coords, ivec2(+1, +1));
            vec4 s54 = textureOffset(u_tex, lookup_coords, ivec2(+2, +1));
            vec4 s64 = textureOffset(u_tex, lookup_coords, ivec2(+3, +1));
            vec4 s05 = textureOffset(u_tex, lookup_coords, ivec2(-3, +2));
            vec4 s15 = textureOffset(u_tex, lookup_coords, ivec2(-2, +2));
            vec4 s25 = textureOffset(u_tex, lookup_coords, ivec2(-1, +2));
            vec4 s35 = textureOffset(u_tex, lookup_coords, ivec2(+0, +2));
            vec4 s45 = textureOffset(u_tex, lookup_coords, ivec2(+1, +2));
            vec4 s55 = textureOffset(u_tex, lookup_coords, ivec2(+2, +2));
            vec4 s65 = textureOffset(u_tex, lookup_coords, ivec2(+3, +2));
            vec4 s06 = textureOffset(u_tex, lookup_coords, ivec2(-3, +3));
            vec4 s16 = textureOffset(u_tex, lookup_coords, ivec2(-2, +3));
            vec4 s26 = textureOffset(u_tex, lookup_coords, ivec2(-1, +3));
            vec4 s36 = textureOffset(u_tex, lookup_coords, ivec2(+0, +3));
            vec4 s46 = textureOffset(u_tex, lookup_coords, ivec2(+1, +3));
            vec4 s56 = textureOffset(u_tex, lookup_coords, ivec2(+2, +3));
            vec4 s66 = textureOffset(u_tex, lookup_coords, ivec2(+3, +3));
            vec4 r0 = sliding_area_7(s00, s10, s20, s30, s40, s50, s60, frac_coords.x);
            vec4 r1 = sliding_area_7(s01, s11, s21, s31, s41, s51, s61, frac_coords.x);
            vec4 r2 = sliding_area_7(s02, s12, s22, s32, s42, s52, s62, frac_coords.x);
            vec4 r3 = sliding_area_7(s03, s13, s23, s33, s43, s53, s63, frac_coords.x);
            vec4 r4 = sliding_area_7(s04, s14, s24, s34, s44, s54, s64, frac_coords.x);
            vec4 r5 = sliding_area_7(s05, s15, s25, s35, s45, s55, s65, frac_coords.x);
            vec4 r6 = sliding_area_7(s06, s16, s26, s36, s46, s56, s66, frac_coords.x);
            color = sliding_area_7(r0, r1, r2, r3, r4, r5, r6, frac_coords.y);
            break;
        }
//        case SQUARES64: {
//            vec2 adjusted_coords = v_tex_coords - 0.5;
//            vec2 int_coords = floor(adjusted_coords);
//            vec2 frac_coords = adjusted_coords - int_coords;
//            vec2 lookup_coords = (int_coords + 0.5) / vec2(textureSize(u_tex, 0));
//            vec4 s00 = textureOffset(u_tex, lookup_coords, ivec2(-3, -3));
//            vec4 s10 = textureOffset(u_tex, lookup_coords, ivec2(-2, -3));
//            vec4 s20 = textureOffset(u_tex, lookup_coords, ivec2(-1, -3));
//            vec4 s30 = textureOffset(u_tex, lookup_coords, ivec2(+0, -3));
//            vec4 s40 = textureOffset(u_tex, lookup_coords, ivec2(+1, -3));
//            vec4 s50 = textureOffset(u_tex, lookup_coords, ivec2(+2, -3));
//            vec4 s60 = textureOffset(u_tex, lookup_coords, ivec2(+3, -3));
//            vec4 s70 = textureOffset(u_tex, lookup_coords, ivec2(+4, -3));
//            vec4 s01 = textureOffset(u_tex, lookup_coords, ivec2(-3, -2));
//            vec4 s11 = textureOffset(u_tex, lookup_coords, ivec2(-2, -2));
//            vec4 s21 = textureOffset(u_tex, lookup_coords, ivec2(-1, -2));
//            vec4 s31 = textureOffset(u_tex, lookup_coords, ivec2(+0, -2));
//            vec4 s41 = textureOffset(u_tex, lookup_coords, ivec2(+1, -2));
//            vec4 s51 = textureOffset(u_tex, lookup_coords, ivec2(+2, -2));
//            vec4 s61 = textureOffset(u_tex, lookup_coords, ivec2(+3, -2));
//            vec4 s71 = textureOffset(u_tex, lookup_coords, ivec2(+4, -2));
//            vec4 s02 = textureOffset(u_tex, lookup_coords, ivec2(-3, -1));
//            vec4 s12 = textureOffset(u_tex, lookup_coords, ivec2(-2, -1));
//            vec4 s22 = textureOffset(u_tex, lookup_coords, ivec2(-1, -1));
//            vec4 s32 = textureOffset(u_tex, lookup_coords, ivec2(+0, -1));
//            vec4 s42 = textureOffset(u_tex, lookup_coords, ivec2(+1, -1));
//            vec4 s52 = textureOffset(u_tex, lookup_coords, ivec2(+2, -1));
//            vec4 s62 = textureOffset(u_tex, lookup_coords, ivec2(+3, -1));
//            vec4 s72 = textureOffset(u_tex, lookup_coords, ivec2(+4, -1));
//            vec4 s03 = textureOffset(u_tex, lookup_coords, ivec2(-3, +0));
//            vec4 s13 = textureOffset(u_tex, lookup_coords, ivec2(-2, +0));
//            vec4 s23 = textureOffset(u_tex, lookup_coords, ivec2(-1, +0));
//            vec4 s33 = textureOffset(u_tex, lookup_coords, ivec2(+0, +0));
//            vec4 s43 = textureOffset(u_tex, lookup_coords, ivec2(+1, +0));
//            vec4 s53 = textureOffset(u_tex, lookup_coords, ivec2(+2, +0));
//            vec4 s63 = textureOffset(u_tex, lookup_coords, ivec2(+3, +0));
//            vec4 s73 = textureOffset(u_tex, lookup_coords, ivec2(+4, +0));
//            vec4 s04 = textureOffset(u_tex, lookup_coords, ivec2(-3, +1));
//            vec4 s14 = textureOffset(u_tex, lookup_coords, ivec2(-2, +1));
//            vec4 s24 = textureOffset(u_tex, lookup_coords, ivec2(-1, +1));
//            vec4 s34 = textureOffset(u_tex, lookup_coords, ivec2(+0, +1));
//            vec4 s44 = textureOffset(u_tex, lookup_coords, ivec2(+1, +1));
//            vec4 s54 = textureOffset(u_tex, lookup_coords, ivec2(+2, +1));
//            vec4 s64 = textureOffset(u_tex, lookup_coords, ivec2(+3, +1));
//            vec4 s74 = textureOffset(u_tex, lookup_coords, ivec2(+4, +1));
//            vec4 s05 = textureOffset(u_tex, lookup_coords, ivec2(-3, +2));
//            vec4 s15 = textureOffset(u_tex, lookup_coords, ivec2(-2, +2));
//            vec4 s25 = textureOffset(u_tex, lookup_coords, ivec2(-1, +2));
//            vec4 s35 = textureOffset(u_tex, lookup_coords, ivec2(+0, +2));
//            vec4 s45 = textureOffset(u_tex, lookup_coords, ivec2(+1, +2));
//            vec4 s55 = textureOffset(u_tex, lookup_coords, ivec2(+2, +2));
//            vec4 s65 = textureOffset(u_tex, lookup_coords, ivec2(+3, +2));
//            vec4 s75 = textureOffset(u_tex, lookup_coords, ivec2(+4, +2));
//            vec4 s06 = textureOffset(u_tex, lookup_coords, ivec2(-3, +3));
//            vec4 s16 = textureOffset(u_tex, lookup_coords, ivec2(-2, +3));
//            vec4 s26 = textureOffset(u_tex, lookup_coords, ivec2(-1, +3));
//            vec4 s36 = textureOffset(u_tex, lookup_coords, ivec2(+0, +3));
//            vec4 s46 = textureOffset(u_tex, lookup_coords, ivec2(+1, +3));
//            vec4 s56 = textureOffset(u_tex, lookup_coords, ivec2(+2, +3));
//            vec4 s66 = textureOffset(u_tex, lookup_coords, ivec2(+3, +3));
//            vec4 s76 = textureOffset(u_tex, lookup_coords, ivec2(+4, +3));
//            vec4 s07 = textureOffset(u_tex, lookup_coords, ivec2(-3, +4));
//            vec4 s17 = textureOffset(u_tex, lookup_coords, ivec2(-2, +4));
//            vec4 s27 = textureOffset(u_tex, lookup_coords, ivec2(-1, +4));
//            vec4 s37 = textureOffset(u_tex, lookup_coords, ivec2(+0, +4));
//            vec4 s47 = textureOffset(u_tex, lookup_coords, ivec2(+1, +4));
//            vec4 s57 = textureOffset(u_tex, lookup_coords, ivec2(+2, +4));
//            vec4 s67 = textureOffset(u_tex, lookup_coords, ivec2(+3, +4));
//            vec4 s77 = textureOffset(u_tex, lookup_coords, ivec2(+4, +4));
//            vec4 r0 = sliding_area_8(s00, s10, s20, s30, s40, s50, s60, s70, frac_coords.x);
//            vec4 r1 = sliding_area_8(s01, s11, s21, s31, s41, s51, s61, s71, frac_coords.x);
//            vec4 r2 = sliding_area_8(s02, s12, s22, s32, s42, s52, s62, s72, frac_coords.x);
//            vec4 r3 = sliding_area_8(s03, s13, s23, s33, s43, s53, s63, s73, frac_coords.x);
//            vec4 r4 = sliding_area_8(s04, s14, s24, s34, s44, s54, s64, s74, frac_coords.x);
//            vec4 r5 = sliding_area_8(s05, s15, s25, s35, s45, s55, s65, s75, frac_coords.x);
//            vec4 r6 = sliding_area_8(s06, s16, s26, s36, s46, s56, s66, s76, frac_coords.x);
//            vec4 r7 = sliding_area_8(s06, s16, s26, s36, s46, s56, s66, s76, frac_coords.x);
//            color = sliding_area_8(r0, r1, r2, r3, r4, r5, r6, r7, frac_coords.y);
//            break;
    }
     // Apply transparency background with alpha blending
    color = color * color.a + u_transparency_background * (1.0 - color.a);
     // Apply color range setting
    color.rgb = color.rgb * u_color_mul + u_color_add;
}"

[ayu::Document {
    program: [liv::PageProgram {
        shaders: [#/vertex+1 #/fragment+1]
    }]
    vertex: [glow::Shader {
        type: GL_VERTEX_SHADER
        source: *vertex_source
    }]
    fragment: [glow::Shader {
        type: GL_FRAGMENT_SHADER
        source: *fragment_source
    }]
}]
